# 测量布局绘制
## onMeasure 
### 测量RecyclerView 分为三种情况 
```java 
protected void onMeasure(int widthSpec, int heightSpec) { 
    if (mLayout == null) { 
        //1. layoutmanager 未设置 
        return; 
    } 
    //mLayout.isAutoMeasureEnabled() 默认false 
    if (mLayout.isAutoMeasureEnabled()) { 
        //2. layoutmanager开启自动测量 
    }else{ 
        //3. layoutmanager未开启自动测量 
    }
} 
``` 
#### 一. 当 __LayoutManager__ 未设置时，不设置View最小值或者padding，不显示 
```java 
if (mLayout == null) { 
    defaultOnMeasure(widthSpec, heightSpec); 
    return; 
} 
//分别测量width 和 height 下面只分析width 
//ViewCompat.getMinimumWidth(this) 返回视图最小宽度 mMinWidth 
void defaultOnMeasure(int widthSpec, int heightSpec) { 
    final int width = LayoutManager.chooseSize(widthSpec,getPaddingLeft() + getPaddingRight(),ViewCompat.getMinimumWidth(this)); 
    final int height = LayoutManager.chooseSize(heightSpec,getPaddingTop() + getPaddingBottom()ViewCompat.getMinimumHeight(this)); 
setMeasuredDimension(width, height); 
} 
public static int chooseSize(int spec, int desired, int min) { 
final int mode = View.MeasureSpec.getMode(spec); 
final int size = View.MeasureSpec.getSize(spec); 
switch (mode) { 
case View.MeasureSpec.EXACTLY: 
//返回match_parent 或者 指定大小 
return size; 
case View.MeasureSpec.AT_MOST: 
//mMinWidth 与 paddingHorizontal取最大值， 再与size取最小值 
return Math.min(size, Math.max(desired, min)); 
case View.MeasureSpec.UNSPECIFIED: 
default: 
//mMinWidth 与 paddingHorizontal取最大值 
return Math.max(desired, min); 
} 
} 
``` 
#### 二. LayoutManager 自动测量 
开启自动测量，在 ``onMeasure()``阶段就把 Children ``layout``完成了。 
```java 
if (mLayout.isAutoMeasureEnabled()) { 
final int widthMode = MeasureSpec.getMode(widthSpec); 
final int heightMode = MeasureSpec.getMode(heightSpec); 
//最后通过recyclerView 调用defaultOnMeasure(int widthSpec, int heightSpec) 
mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); 
//如果width 和 height 都指定了大小，或者 未设置adapter 时，不用再测量子View大小 
final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY && heightMode == MeasureSpec.EXACTLY; 
if (measureSpecModeIsExactly || mAdapter == null) { 
return; 
} 
//mState.mLayoutStep 解释看下面表格 
if (mState.mLayoutStep == State.STEP_START) { 
//看下一个代码块 
dispatchLayoutStep1(); 
} 
// set dimensions in 2nd step. Pre-layout should happen with old dimensions for 
// consistency 
mLayout.setMeasureSpecs(widthSpec, heightSpec); 
mState.mIsMeasuring = true; 
//主要布局测量 
dispatchLayoutStep2(); 
// now we can get the width and height from the children. 
mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); 
// if RecyclerView has non-exact width and height and if there is at least one child 
// which also has non-exact width & height, we have to re-measure. 
if (mLayout.shouldMeasureTwice()) { 
mLayout.setMeasureSpecs( 
MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), 
MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); 
mState.mIsMeasuring = true; 
dispatchLayoutStep2(); 
// now we can get the width and height from the children. 
mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); 
} 
} 
``` 
State | 含义 
- | - 
__State.STEP_START__ | ``mState.mLayoutStep``的默认值，这种情况下，表示 __RecyclerView__ 还未经历 _dispatchLayoutStep1_ ，因为 _dispatchLayoutStep1_ 调用之后 ``mState.mLayoutStep``会变为 __State.STEP_LAYOUT__。 
__State.STEP_LAYOUT__ | 当 ``mState.mLayoutStep``为 __State.STEP_LAYOUT__ 时，表示此时处于``layout``阶段，这个阶段会调用 _dispatchLayoutStep2_ 方法``layout`` __RecyclerView__ 的``children``。调用 _dispatchLayoutStep2_ 方法之后，此时``mState.mLayoutStep``变为了 __State.STEP_ANIMATIONS__。 
__State.STEP_ANIMATIONS__ | 当``mState.mLayoutStep``为 __State.STEP_ANIMATIONS__ 时，表示 __RecyclerView__ 处于第三个阶段，也就是执行动画的阶段，也就是调用 _dispatchLayoutStep3_ 方法。当 _dispatchLayoutStep3_ 方法执行完毕之后，``mState.mLayoutStep``又变为了 __State.STEP_START__ 
##### 1. dispatchLayoutStep1() 
本方法也被称为 __preLayout(预布局)__ ，当 __Adapter__ 更新了，这个方法会保存每个 __ItemView__ 的旧信息(oldViewHolderInfo) 
* 处理 __Adapter__ 更新 
* 决定是否执行 __ItemAnimator__ 
* 保存 __ItemView__ 的动画信息。 
```java 
/** 
* - 适配器更新过程 
* - 决定哪些动画应该运行 
* - 保存当前视图的信息 
* - 如果有必要,运行预测布局和保存的信息 
*/ 
private void dispatchLayoutStep1() { 
//检查是State.STEP_START状态 
mState.assertLayoutStep(State.STEP_START); 
fillRemainingScrollValues(mState); 
mState.mIsMeasuring = false; 
startInterceptRequestLayout(); 
mViewInfoStore.clear(); 
onEnterLayoutOrScroll(); 
processAdapterUpdatesAndSetAnimationFlags(); 
saveFocusInfo(); 
mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations && mItemsChanged; 
mItemsAddedOrRemoved = mItemsChanged = false; 
mState.mInPreLayout = mState.mRunPredictiveAnimations; 
mState.mItemCount = mAdapter.getItemCount(); 
findMinMaxChildLayoutPositions(mMinMaxLayoutPositions); 
if (mState.mRunSimpleAnimations) { 
// Step 0: 找到没有被remove的ItemView,保存OldViewHolder信息，准备预布局 
int count = mChildHelper.getChildCount(); 
for (int i = 0; i < count; ++i) { 
final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); 
if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) { 
continue; 
} 
final ItemHolderInfo animationInfo = mItemAnimator 
.recordPreLayoutInformation(mState, holder, 
ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), 
holder.getUnmodifiedPayloads()); 
mViewInfoStore.addToPreLayout(holder, animationInfo); 
if (mState.mTrackOldChangeHolders && holder.isUpdated() && !holder.isRemoved() 
&& !holder.shouldIgnore() && !holder.isInvalid()) { 
long key = getChangedHolderKey(holder); 
// This is NOT the only place where a ViewHolder is added to old change holders 
// list. There is another case where: 
// * A VH is currently hidden but not deleted 
// * The hidden item is changed in the adapter 
// * Layout manager decides to layout the item in the pre-Layout pass (step1) 
// When this case is detected, RV will un-hide that view and add to the old 
// change holders list. 
mViewInfoStore.addToOldChangeHolders(key, holder); 
} 
} 
} 
if (mState.mRunPredictiveAnimations) { 
//进行预布局 
// Step 1: run prelayout: This will use the old positions of items. The layout manager 
// is expected to layout everything, even removed items (though not to add removed 
// items back to the container). This gives the pre-layout position of APPEARING views 
// which come into existence as part of the real layout. 
// Save old positions so that LayoutManager can run its mapping logic. 
saveOldPositions(); 
final boolean didStructureChange = mState.mStructureChanged; 
mState.mStructureChanged = false; 
// temporarily disable flag because we are asking for previous layout 
mLayout.onLayoutChildren(mRecycler, mState); 
mState.mStructureChanged = didStructureChange; 
for (int i = 0; i < mChildHelper.getChildCount(); ++i) { 
final View child = mChildHelper.getChildAt(i); 
final ViewHolder viewHolder = getChildViewHolderInt(child); 
if (viewHolder.shouldIgnore()) { 
continue; 
} 
if (!mViewInfoStore.isInPreLayout(viewHolder)) { 
int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder); 
boolean wasHidden = viewHolder 
.hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); 
if (!wasHidden) { 
flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; 
} 
final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation( 
mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads()); 
if (wasHidden) { 
recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo); 
} else { 
mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo); 
} 
} 
} 
// we don't process disappearing list because they may re-appear in post layout pass. 
clearOldPositions(); 
} else { 
clearOldPositions(); 
} 
onExitLayoutOrScroll(); 
stopInterceptRequestLayout(false); 
//状态改为布局 
mState.mLayoutStep = State.STEP_LAYOUT; 
} 
``` 
_mRunSimpleAnimations_ 与 _mFirstLayoutComplete_ 的值有关， _mRunPredictiveAnimations_ 的值还与 _mRunSimpleAnimations_ 有关。所以这里我们可以得出一个结论,当RecyclerView第一次加载数据时，是不会执行的动画。 换句话说就是 __ItemView__ 还没有 _layout_ 。 
```java 
//在测量和分派的布局使用适配器更新和计算哪种我们想要运行类型的动画 
//这种方法只能处理pre-layout状态更新或全部 
private void processAdapterUpdatesAndSetAnimationFlags() { 
if (mDataSetHasChangedAfterLayout) { 
// Processing these items have no value since data set changed unexpectedly. 
// Instead, we just reset it. 
mAdapterHelper.reset(); 
if (mDispatchItemsChangedEvent) { 
mLayout.onItemsChanged(this); 
} 
} 
// simple animations are a subset of advanced animations (which will cause a 
// pre-layout step) 
// If layout supports predictive animations, pre-process to decide if we want to run them 
if (predictiveItemAnimationsEnabled()) { 
mAdapterHelper.preProcess(); 
} else { 
mAdapterHelper.consumeUpdatesInOnePass(); 
} 
boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged; 
mState.mRunSimpleAnimations = mFirstLayoutComplete 
&& mItemAnimator != null 
&& (mDataSetHasChangedAfterLayout 
|| animationTypeSupported 
|| mLayout.mRequestedSimpleAnimations) 
&& (!mDataSetHasChangedAfterLayout 
|| mAdapter.hasStableIds()); 
mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations 
&& animationTypeSupported 
&& !mDataSetHasChangedAfterLayout 
&& predictiveItemAnimationsEnabled(); 
} 
``` 
##### 2. dispatchLayoutStep2() 
本方法进行的是 子View 的测量和布局,放在最后面讲 
主要是 __LayoutManager__ 调用 ``onLayoutChildren()``方法，去布局姿势图。``onLayoutChildren()``是空方法，需要继承 __LayoutManager__ 的子类自己实现，从而决定不同的 __LayoutManager__ 不同的样式。 
```java 
private void dispatchLayoutStep2() { 
startInterceptRequestLayout(); 
onEnterLayoutOrScroll(); 
mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); 
mAdapterHelper.consumeUpdatesInOnePass(); 
mState.mItemCount = mAdapter.getItemCount(); 
mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; 
// Step 2: Run layout 
mState.mInPreLayout = false; 
mLayout.onLayoutChildren(mRecycler, mState); 
mState.mStructureChanged = false; 
mPendingSavedState = null; 
// onLayoutChildren may have caused client code to disable item animations; re-check 
mState.mRunSimpleAnimations = mState.mRunSimpleAnimations && mItemAnimator != null; 
mState.mLayoutStep = State.STEP_ANIMATIONS; 
onExitLayoutOrScroll(); 
stopInterceptRequestLayout(false); 
} 
``` 
#### 三. 没有开启自动测量 
没有开启自动测量，则在layout阶段才布局Children 
接下来又分为两种情况，开启和未开启``setHasFixedSize()`` 
1. 开启``setHasFixedSize()``将直接调用 __LayoutManager__ 的``onMeasure()``方法进行测量。 
2. 未开启``setHasFixedSize()``，此时如果有数据更新，先处理数据更新的事物，然后调用 __LayoutManager__ 的``onMeasure()``方法进行测量。 
```java 
else{ 
if (mHasFixedSize) { 
mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); 
return; 
} 
// custom onMeasure 
if (mAdapterUpdateDuringMeasure) { 
startInterceptRequestLayout(); 
onEnterLayoutOrScroll(); 
processAdapterUpdatesAndSetAnimationFlags(); 
onExitLayoutOrScroll(); 
if (mState.mRunPredictiveAnimations) { 
mState.mInPreLayout = true; 
} else { 
// consume remaining updates to provide a consistent state with the layout pass. 
mAdapterHelper.consumeUpdatesInOnePass(); 
mState.mInPreLayout = false; 
} 
mAdapterUpdateDuringMeasure = false; 
stopInterceptRequestLayout(false); 
} else if (mState.mRunPredictiveAnimations) { 
// If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true: 
// this means there is already an onMeasure() call performed to handle the pending 
// adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout 
// with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time 
// because getViewForPosition() will crash when LM uses a child to measure. 
setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); 
return; 
} 
if (mAdapter != null) { 
mState.mItemCount = mAdapter.getItemCount(); 
} else { 
mState.mItemCount = 0; 
} 
startInterceptRequestLayout(); 
mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); 
stopInterceptRequestLayout(false); 
mState.mInPreLayout = false; // clear 
} 
``` 
## onLayout 
``onLayout()``里面做了两件事，一个是调用了``dispatchLayout()``方法，另一个是 _mFirstLayoutComplete_ 改为了``true``。 
```java 
@Override 
protected void onLayout(boolean changed, int l, int t, int r, int b) { 
TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); 
dispatchLayout(); 
TraceCompat.endSection(); 
mFirstLayoutComplete = true; 
} 
``` 
#### dispatchLayout() 
先判断 是否有 __Adapter__ 和 __LayoutManager__ ，没有则 __return__ ; 
接下来会有三种情况 
* 当 __mState.mLayoutStep__ 为 __State.STEP_START__ 时，会先执行``dispatchLayoutStep1()``和``dispatchLayoutStep2()``两个方法。 
* __Adapter__ 更新，或者宽高需要重新测量会执行``dispatchLayoutStep2()``方法。 
* 只是将 __RecyclerView__ 的宽高 赋值给 __LayoutManager__ 。 
最后会执行 ``dispatchLayoutStep3()``方法 
```java 
void dispatchLayout() { 
if (mAdapter == null) { 
Log.e(TAG, "No adapter attached; skipping layout"); 
// leave the state in START 
return; 
} 
if (mLayout == null) { 
Log.e(TAG, "No layout manager attached; skipping layout"); 
// leave the state in START 
return; 
} 
mState.mIsMeasuring = false; 
if (mState.mLayoutStep == State.STEP_START) { 
dispatchLayoutStep1(); 
mLayout.setExactMeasureSpecsFrom(this); 
dispatchLayoutStep2(); 
} else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() 
|| mLayout.getHeight() != getHeight()) { 
// First 2 steps are done in onMeasure but looks like we have to run again due to 
// changed size. 
mLayout.setExactMeasureSpecsFrom(this); 
dispatchLayoutStep2(); 
} else { 
// always make sure we sync them (to ensure mode is exact) 
mLayout.setExactMeasureSpecsFrom(this); 
} 
dispatchLayoutStep3(); 
} 
``` 
##### dispatchLayoutStep3() 
这个方法的作用执行在``dispatchLayoutStep1()``方法里面保存的动画信息。 
```java 
private void dispatchLayoutStep3() { 
mState.assertLayoutStep(State.STEP_ANIMATIONS); 
startInterceptRequestLayout(); 
onEnterLayoutOrScroll(); 
//将 mState.mLayoutStep又变为了State.STEP_START 
mState.mLayoutStep = State.STEP_START; 
if (mState.mRunSimpleAnimations) { 
// Step 3: Find out where things are now, and process change animations. 
// traverse list in reverse because we may call animateChange in the loop which may 
// remove the target view holder. 
for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) { 
ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); 
if (holder.shouldIgnore()) { 
continue; 
} 
long key = getChangedHolderKey(holder); 
final ItemHolderInfo animationInfo = mItemAnimator 
.recordPostLayoutInformation(mState, holder); 
ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); 
if (oldChangeViewHolder != null && !oldChangeViewHolder.shouldIgnore()) { 
// run a change animation 
// If an Item is CHANGED but the updated version is disappearing, it creates 
// a conflicting case. 
// Since a view that is marked as disappearing is likely to be going out of 
// bounds, we run a change animation. Both views will be cleaned automatically 
// once their animations finish. 
// On the other hand, if it is the same view holder instance, we run a 
// disappearing animation instead because we are not going to rebind the updated 
// VH unless it is enforced by the layout manager. 
final boolean oldDisappearing = mViewInfoStore.isDisappearing( 
oldChangeViewHolder); 
final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); 
if (oldDisappearing && oldChangeViewHolder == holder) { 
// run disappear animation instead of change 
mViewInfoStore.addToPostLayout(holder, animationInfo); 
} else { 
final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( 
oldChangeViewHolder); 
// we add and remove so that any post info is merged. 
mViewInfoStore.addToPostLayout(holder, animationInfo); 
ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); 
if (preInfo == null) { 
handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); 
} else { 
animateChange(oldChangeViewHolder, holder, preInfo, postInfo, 
oldDisappearing, newDisappearing); 
} 
} 
} else { 
mViewInfoStore.addToPostLayout(holder, animationInfo); 
} 
} 
// Step 4: Process view info lists and trigger animations 
mViewInfoStore.process(mViewInfoProcessCallback); 
} 
mLayout.removeAndRecycleScrapInt(mRecycler); 
mState.mPreviousLayoutItemCount = mState.mItemCount; 
mDataSetHasChangedAfterLayout = false; 
mDispatchItemsChangedEvent = false; 
mState.mRunSimpleAnimations = false; 
mState.mRunPredictiveAnimations = false; 
mLayout.mRequestedSimpleAnimations = false; 
if (mRecycler.mChangedScrap != null) { 
mRecycler.mChangedScrap.clear(); 
} 
if (mLayout.mPrefetchMaxObservedInInitialPrefetch) { 
// Initial prefetch has expanded cache, so reset until next prefetch. 
// This prevents initial prefetches from expanding the cache permanently. 
mLayout.mPrefetchMaxCountObserved = 0; 
mLayout.mPrefetchMaxObservedInInitialPrefetch = false; 
mRecycler.updateViewCacheSize(); 
} 
mLayout.onLayoutCompleted(mState); 
onExitLayoutOrScroll(); 
stopInterceptRequestLayout(false); 
mViewInfoStore.clear(); 
if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) { 
dispatchOnScrolled(0, 0); 
} 
recoverFocusFromState(); 
resetFocusInfo(); 
} 
``` 
## draw 
重写了 ``draw()``和 ``onDraw()``两个方法。 
### draw() 
``draw()``方法分为三步。 
1. 首先调用 ``super.draw()``,将 __Children__ 的绘制分发给 __ViewGroup__ ,将分割线绘制分发给 __ItemDecoration__ 
2. 如果需要的话，调用 __ItemDecoration__ 的 ``onDrawOver``方法。通过这个方法，我们在每个 __ItemView__ 上面画上很多东西。 
3. 如果 __RecyclerView__ 调用了``setClipToPadding()``,会实现一种特殊的滑动效果--每个 __ItemView__ 可以滑动到``padding``区域。 
```java 
public void draw(Canvas c) { 
// 第一步 
super.draw(c); 
// 第二步 
final int count = mItemDecorations.size(); 
for (int i = 0; i < count; i++) { 
mItemDecorations.get(i).onDrawOver(c, this, mState); 
} 
// 第三步 
// TODO If padding is not 0 and clipChildrenToPadding is false, to draw glows properly, we 
// need find children closest to edges. Not sure if it is worth the effort. 
// ······ 
} 
``` 
第一步会回调``onDraw()``方法，调用了 __ItemDecoration__ 的``onDraw()``方法，也就是说``onDraw()``是在 __Itemview__ 绘制之前，``onDrawOver()``是在 __Itemview__ 绘制之后 
```java 
@Override 
public void onDraw(Canvas c) { 
super.onDraw(c); 
final int count = mItemDecorations.size(); 
for (int i = 0; i < count; i++) { 
mItemDecorations.get(i).onDraw(c, this, mState); 
} 
} 
``` 
## LayoutManager的onLayoutChildren方法 

在``dispatchLayoutStep1()``和``dispatchLayoutStep2()``中都有调用， 
它本身没有实现任何东西，需要看他的子类。以 __LinearLayoutManager__ 为例。 

### AnchorInfo
__锚点位置__ 这是LinearLayoutManager 的一个内部类，他主要有三个属性。
* 	int mPosition 锚点参考View在整个数据中的position信息，即它是第几个View
*	int mCoordinate 锚点的具体坐标信息，填充子View的起始坐标
*	boolean mLayoutFromEnd 是否从尾部开始布局，默认为false

```java
public void assignFromView(View child, int position) {
    if (mLayoutFromEnd) {
        mCoordinate = mOrientationHelper.getDecoratedEnd(child)
                + mOrientationHelper.getTotalSpaceChange();
    } else {
        // 顺向布局进这里，选取子View的最上点作为锚点坐标
        mCoordinate = mOrientationHelper.getDecoratedStart(child);
    }
    // mPosition 赋值为参考View的position
    mPosition = position;
}
```

```java 
@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    // layout 算法:
    // 找到页面当前锚点坐标和item位置
    // 1) by checking children and other variables, find an anchor coordinate and an anchor
    //  item position.
    // 从底部开始堆栈，从顶部结束堆栈
    // 2) fill towards start, stacking from bottom
    // 3) fill towards end, stacking from top
    // 滚动以满足需求从底部堆栈
    // 4) scroll to fulfill requirements like stack from bottom.
    // create layout state
    
    // mPendingSavedState 只有在onRestoreInstanceState时才会设置实例
    // mPendingScrollPosition 默认 NO_POSITION，滚动会更新
    if (mPendingSavedState != null || mPendingScrollPosition != NO_POSITION) {
        if (state.getItemCount() == 0) {
            removeAndRecycleAllViews(recycler);
            return;
        }
    }
    if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
        mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
    }
    // 确保 mLayoutState 不为null
    ensureLayoutState();
    // 不回收children
    mLayoutState.mRecycle = false;
    // resolve layout direction
    // 修改 mShouldReverseLayout 这个属性
    // 确定是正序还是倒序 默认是正序，也就是 mShouldReverseLayout 默认是 false
    resolveShouldLayoutReverse();
    // 第一步 计算锚点
    final View focused = getFocusedChild();
    // mValid 默认是false
    if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION || mPendingSavedState != null) {
        // AnchorInfo初始化 mValid也会变为false
        mAnchorInfo.reset();
        // 上面说了 mShouldReverseLayout 默认是false，
        // mStackFromEnd 默认也是 false
        // 所以 mAnchorInfo.mLayoutFromEnd 默认也是false
        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
        // calculate anchor position and coordinate
        // 计算锚点的位置和偏移量,下一个代码块单独解释
        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
        mAnchorInfo.mValid = true;
    } else if (focused != null && (mOrientationHelper.getDecoratedStart(focused)
                    >= mOrientationHelper.getEndAfterPadding()
            || mOrientationHelper.getDecoratedEnd(focused)
            <= mOrientationHelper.getStartAfterPadding())) {
        // This case relates to when the anchor child is the focused view and due to layout
        // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows
        // up after tapping an EditText which shrinks RV causing the focused view (The tapped
        // EditText which is the anchor child) to get kicked out of the screen. Will update the
        // anchor coordinate in order to make sure that the focused view is laid out. Otherwise,
        // the available space in layoutState will be calculated as negative preventing the
        // focused view from being laid out in fill.
        // Note that we won't update the anchor position between layout passes (refer to
        // TestResizingRelayoutWithAutoMeasure), which happens if we were to call
        // updateAnchorInfoForLayout for an anchor that's not the focused view (e.g. a reference
        // child which can change between layout passes).
        // 大概可以理解 这种情况锚点位置与焦点有关，需要重新计算
        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
    }

    // LLM may decide to layout items for "extra" pixels to account for scrolling target,
    // caching or predictive animations.
    int extraForStart;
    int extraForEnd;
    final int extra = getExtraLayoutSpace(state);
    // If the previous scroll delta was less than zero, the extra space should be laid out
    // at the start. Otherwise, it should be at the end.
    if (mLayoutState.mLastScrollDelta >= 0) {
        extraForEnd = extra;
        extraForStart = 0;
    } else {
        extraForStart = extra;
        extraForEnd = 0;
    }
    extraForStart += mOrientationHelper.getStartAfterPadding();
    extraForEnd += mOrientationHelper.getEndPadding();
    if (state.isPreLayout() && mPendingScrollPosition != NO_POSITION
            && mPendingScrollPositionOffset != INVALID_OFFSET) {
        // if the child is visible and we are going to move it around, we should layout
        // extra items in the opposite direction to make sure new items animate nicely
        // instead of just fading in
        final View existing = findViewByPosition(mPendingScrollPosition);
        if (existing != null) {
            final int current;
            final int upcomingOffset;
            if (mShouldReverseLayout) {
                current = mOrientationHelper.getEndAfterPadding()
                        - mOrientationHelper.getDecoratedEnd(existing);
                upcomingOffset = current - mPendingScrollPositionOffset;
            } else {
                current = mOrientationHelper.getDecoratedStart(existing)
                        - mOrientationHelper.getStartAfterPadding();
                upcomingOffset = mPendingScrollPositionOffset - current;
            }
            if (upcomingOffset > 0) {
                extraForStart += upcomingOffset;
            } else {
                extraForEnd -= upcomingOffset;
            }
        }
    }
    
    int startOffset;
    int endOffset;
    final int firstLayoutDirection;
    if (mAnchorInfo.mLayoutFromEnd) {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL
                : LayoutState.ITEM_DIRECTION_HEAD;
    } else {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD
                : LayoutState.ITEM_DIRECTION_TAIL;
    }

    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
    // 第二步 缓存机制
    detachAndScrapAttachedViews(recycler);
    mLayoutState.mInfinite = resolveIsInfinite();
    mLayoutState.mIsPreLayout = state.isPreLayout();
    // 第三步 填充children
    if (mAnchorInfo.mLayoutFromEnd) {
        // 默认为false，两个情况逻辑相同，只分析false
    } else {
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = extraForEnd;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
        final int lastElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForStart += mLayoutState.mAvailable;
        }
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = extraForStart;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;

        if (mLayoutState.mAvailable > 0) {
            extraForEnd = mLayoutState.mAvailable;
            // start could not consume all it should. add more items towards end
            updateLayoutStateToFillEnd(lastElement, endOffset);
            mLayoutState.mExtra = extraForEnd;
            fill(recycler, mLayoutState, state, false);
            endOffset = mLayoutState.mOffset;
        }
    }

    // changes may cause gaps on the UI, try to fix them.
    // TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have
    // changed
    if (getChildCount() > 0) {
        // because layout from end may be changed by scroll to position
        // we re-calculate it.
        // find which side we should check for gaps.
        if (mShouldReverseLayout ^ mStackFromEnd) {
            int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        } else {
            int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        }
    }
    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);
    if (!state.isPreLayout()) {
        mOrientationHelper.onLayoutComplete();
    } else {
        mAnchorInfo.reset();
    }
    mLastStackFromEnd = mStackFromEnd;
    if (DEBUG) {
        validateChildOrder();
    }
}
``` 

### 第一步
```java
final View focused = getFocusedChild();
if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION
        || mPendingSavedState != null) {
    mAnchorInfo.reset();
    mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
    // calculate anchor position and coordinate
    updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
    mAnchorInfo.mValid = true;
} else if (focused != null && (mOrientationHelper.getDecoratedStart(focused)
                >= mOrientationHelper.getEndAfterPadding()
        || mOrientationHelper.getDecoratedEnd(focused)
        <= mOrientationHelper.getStartAfterPadding())) {
    mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
}
```

updateAnchorInfoForLayout()  有三种计算锚点的方式：
1. __RecyclerView__ 被重建，期间回调了``onSaveInstanceState``方法， __RecyclerView__ 自带恢复上次布局。 __RecyclerView__ 调用了``scrollToPosition``之类的方法，目的是让 __RecyclerView__ 滚动准确位置。
2. 如果当前有`child`拥有焦点，用当前`child`的位置计算锚点。如果没有`child`拥有焦点，那么根据布局方向(此时布局方向由``mLayoutFromEnd``来决定)获取可见的第一个 __ItemView__ 或者最后一个 __ItemView__ 。
3. 如果前面两种方式都计算失败了，那么采用第三种计算方式，也就是默认的计算方式。

```java
private void updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorInfo) {
    // 更新锚信息等待信息
    // 方法注释：如果有一个悬而未决的滚动位置或保存状态,更新锚信息数据和返回true，todo....
    if (updateAnchorFromPendingData(state, anchorInfo)) {
        return;
    }
    //从现有child锚更新信息
    if (updateAnchorFromChildren(recycler, state, anchorInfo)) {
        return;
    }
    //没用能做参考的子View，直接选取可见区域最顶端（要考虑padding，反向则是底端）作为锚点
    anchorInfo.assignCoordinateFromPadding();
    anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;
}
```

```java
private boolean updateAnchorFromChildren(RecyclerView.Recycler recycler,
        RecyclerView.State state, AnchorInfo anchorInfo) {
    if (getChildCount() == 0) {
        return false;
    }
    final View focused = getFocusedChild();
    // 优先选取获得焦点的子View作为锚点
    if (focused != null && anchorInfo.isViewValidAsAnchor(focused, state)) {
        anchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
        return true;
    }
    if (mLastStackFromEnd != mStackFromEnd) {
        return false;
    }
    // 上面说过 anchorInfo.mLayoutFromEnd默认是false
    // 所以一般情况下会选取最上（反向布局则是最下）的子View作为锚点参考
    // 在一般正向布局的情况下，会选取第一个可见子View的最上点为锚点的坐标（使用ItemDecorator装饰的位置也要考虑进去）
    View referenceChild = anchorInfo.mLayoutFromEnd
            ? findReferenceChildClosestToEnd(recycler, state)
            : findReferenceChildClosestToStart(recycler, state);
    if (referenceChild != null) {
        // 赋予锚点信息 设置AnchorInfo里面的几个属性
        // 这个方法源码在 AnchorInfo 里
        anchorInfo.assignFromView(referenceChild, getPosition(referenceChild));
        // If all visible views are removed in 1 pass, reference child might be out of bounds.
        // If that is the case, offset it back to 0 so that we use these pre-layout children.
        if (!state.isPreLayout() && supportsPredictiveItemAnimations()) {
            // validate this child is at least partially visible. if not, offset it to start
            final boolean notVisible =
                    mOrientationHelper.getDecoratedStart(referenceChild) >= mOrientationHelper
                            .getEndAfterPadding()
                            || mOrientationHelper.getDecoratedEnd(referenceChild)
                            < mOrientationHelper.getStartAfterPadding();
            if (notVisible) {
                anchorInfo.mCoordinate = anchorInfo.mLayoutFromEnd
                        ? mOrientationHelper.getEndAfterPadding()
                        : mOrientationHelper.getStartAfterPadding();
            }
        }
        return true;
    }
    return false;
}
```
![RecyclerView布局](https://upload-images.jianshu.io/upload_images/7142965-64a0d1eb3f0f33e7.png)

### 第三步

根据布局方向(``mAnchorInfo.mLayoutFromEnd``),关键代码是``fill()``。
```java
if (mAnchorInfo.mLayoutFromEnd) {
    // fill towards start
    updateLayoutStateToFillStart(mAnchorInfo);
    mLayoutState.mExtra = extraForStart;
    fill(recycler, mLayoutState, state, false);
    startOffset = mLayoutState.mOffset;
    final int firstElement = mLayoutState.mCurrentPosition;
    if (mLayoutState.mAvailable > 0) {
        extraForEnd += mLayoutState.mAvailable;
    }
    // fill towards end
    updateLayoutStateToFillEnd(mAnchorInfo);
    mLayoutState.mExtra = extraForEnd;
    mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
    fill(recycler, mLayoutState, state, false);
    endOffset = mLayoutState.mOffset;

    if (mLayoutState.mAvailable > 0) {
        // end could not consume all. add more items towards start
        extraForStart = mLayoutState.mAvailable;
        updateLayoutStateToFillStart(firstElement, startOffset);
        mLayoutState.mExtra = extraForStart;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;
    }
} else {
    // fill towards end
    updateLayoutStateToFillEnd(mAnchorInfo);
    mLayoutState.mExtra = extraForEnd;
    fill(recycler, mLayoutState, state, false);
    endOffset = mLayoutState.mOffset;
    final int lastElement = mLayoutState.mCurrentPosition;
    if (mLayoutState.mAvailable > 0) {
        extraForStart += mLayoutState.mAvailable;
    }
    // fill towards start
    updateLayoutStateToFillStart(mAnchorInfo);
    mLayoutState.mExtra = extraForStart;
    mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
    fill(recycler, mLayoutState, state, false);
    startOffset = mLayoutState.mOffset;

    if (mLayoutState.mAvailable > 0) {
        extraForEnd = mLayoutState.mAvailable;
        // start could not consume all it should. add more items towards end
        updateLayoutStateToFillEnd(lastElement, endOffset);
        mLayoutState.mExtra = extraForEnd;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
    }
}
```

__fill__ 它里面就进行了RecyclerView中最关键的步骤：回收移除不再显示的View，并在屏幕上堆叠出要展示的View来。堆叠的实现的逻辑很简单，就是判断当前可见区域还有没有剩余空间，如果有的话就再填充一个View上去，使用一个while循环来实现。如果需要填充，就会调用layoutChunk()方法来完成填充工作。

事实上在LinearLayoutManager中，进行界面重绘和进行滑动两种情况下，往屏幕上填充子View的工作都是调用fill()进行的。两者的区别在于，界面重绘的时候，前一步会将已布局的View进行清空并重新填充界面，而滑动的时候，只需要根据滑动的距离计算出经过滑动以后有没有空出新的位置需要填充就可以了。


```java
int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
        RecyclerView.State state, boolean stopOnFocusable) {
    // max offset we should set is mFastScroll + available
    final int start = layoutState.mAvailable;
    if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
        // TODO ugly bug fix. should not happen
        if (layoutState.mAvailable < 0) {
            layoutState.mScrollingOffset += layoutState.mAvailable;
        }
        //回收掉已经滑出屏幕的View
        recycleByLayoutState(recycler, layoutState);
    }
    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
    //进入循环，无论是滑动还是界面重绘时，只要还有空出的位置就要进行填充
    while ((layoutState.mInfinite || remainingSpace > 0) && layoutState.hasMore(state)) {
        layoutChunkResult.resetInternal();
        //填充一个View到屏幕上
        layoutChunk(recycler, state, layoutState, layoutChunkResult);
        if (layoutChunkResult.mFinished) {
            break;
        }
        layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection;
        /**
         * Consume the available space if:
         * * layoutChunk did not request to be ignored
         * * OR we are laying out scrap children
         * * OR we are not doing pre-layout
         */
        if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null
                || !state.isPreLayout()) {
            layoutState.mAvailable -= layoutChunkResult.mConsumed;
            // we keep a separate remaining space because mAvailable is important for recycling
            //如果进行了填充，就要在计算时消耗掉填充使用了的空间
            remainingSpace -= layoutChunkResult.mConsumed;
        }

        if (layoutState.mScrollingOffset != LayoutState.SCROLLING_OFFSET_NaN) {
            layoutState.mScrollingOffset += layoutChunkResult.mConsumed;
            if (layoutState.mAvailable < 0) {
                layoutState.mScrollingOffset += layoutState.mAvailable;
            }
            recycleByLayoutState(recycler, layoutState);
        }
        if (stopOnFocusable && layoutChunkResult.mFocusable) {
            break;
        }
    }
    if (DEBUG) {
        validateChildOrder();
    }
    return start - layoutState.mAvailable;
}
```

循环中的layoutChunk()

```java
void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
        LayoutState layoutState, LayoutChunkResult result) {
    View view = layoutState.next(recycler);
    if (view == null) {
        if (DEBUG && layoutState.mScrapList == null) {
            throw new RuntimeException("received null view when unexpected");
        }
        // if we are laying out views in scrap, this may return null which means there is
        // no more items to layout.
        result.mFinished = true;
        return;
    }
    LayoutParams params = (LayoutParams) view.getLayoutParams();
    if (layoutState.mScrapList == null) {
        if (mShouldReverseLayout == (layoutState.mLayoutDirection
                == LayoutState.LAYOUT_START)) {
            addView(view);
        } else {
            addView(view, 0);
        }
    } else {
        if (mShouldReverseLayout == (layoutState.mLayoutDirection
                == LayoutState.LAYOUT_START)) {
            addDisappearingView(view);
        } else {
            addDisappearingView(view, 0);
        }
    }
    measureChildWithMargins(view, 0, 0);
    result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view);
    int left, top, right, bottom;
    if (mOrientation == VERTICAL) {
        if (isLayoutRTL()) {
            right = getWidth() - getPaddingRight();
            left = right - mOrientationHelper.getDecoratedMeasurementInOther(view);
        } else {
            left = getPaddingLeft();
            right = left + mOrientationHelper.getDecoratedMeasurementInOther(view);
        }
        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
            bottom = layoutState.mOffset;
            top = layoutState.mOffset - result.mConsumed;
        } else {
            top = layoutState.mOffset;
            bottom = layoutState.mOffset + result.mConsumed;
        }
    } else {
        top = getPaddingTop();
        bottom = top + mOrientationHelper.getDecoratedMeasurementInOther(view);

        if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) {
            right = layoutState.mOffset;
            left = layoutState.mOffset - result.mConsumed;
        } else {
            left = layoutState.mOffset;
            right = layoutState.mOffset + result.mConsumed;
        }
    }
    // We calculate everything with View's bounding box (which includes decor and margins)
    // To calculate correct layout position, we subtract margins.
    layoutDecoratedWithMargins(view, left, top, right, bottom);
    if (DEBUG) {
        Log.d(TAG, "laid out child at position " + getPosition(view) + ", with l:"
                + (left + params.leftMargin) + ", t:" + (top + params.topMargin) + ", r:"
                + (right - params.rightMargin) + ", b:" + (bottom - params.bottomMargin));
    }
    // Consume the available space if the view is not removed OR changed
    if (params.isItemRemoved() || params.isItemChanged()) {
        result.mIgnoreConsumed = true;
    }
    result.mFocusable = view.hasFocusable();
}

```

准备一个将要用来布局的View，缓存里没有的话就要创建将会按照缓存层级的顺序依次优先从Scrap、ViewCacheExtension、CacheViews、RecycledViewPool中尝试获取，如果都没有获取到，就调用一次createViewHolder()重新创建一个。然后就是添加这个View进来并进行测量和布局了。

```java
View next(RecyclerView.Recycler recycler) {
    // 缓存
    if (mScrapList != null) {
        return nextViewFromScrapList();
    }
    // createViewHolder()
    final View view = recycler.getViewForPosition(mCurrentPosition);
    mCurrentPosition += mItemDirection;
    return view;
}

```
nextViewFromScrapList()
```java
private View nextViewFromScrapList() {
    final int size = mScrapList.size();
    for (int i = 0; i < size; i++) {
        final View view = mScrapList.get(i).itemView;
        final LayoutParams lp = (LayoutParams) view.getLayoutParams();
        if (lp.isItemRemoved()) {
            continue;
        }
        if (mCurrentPosition == lp.getViewLayoutPosition()) {
            assignPositionFromScrapList(view);
            return view;
        }
    }
    return null;
}

```


[TOC] 

