[TOC] 
## onMeasure 
#### 测量RecyclerView 分为三种情况 
```java 
protected void onMeasure(int widthSpec, int heightSpec) { 
    if (mLayout == null) { 
        //1. layoutmanager 未设置 
        return; 
    } 
    //mLayout.isAutoMeasureEnabled() 默认false 
    if (mLayout.isAutoMeasureEnabled()) { 
        //2. layoutmanager开启自动测量 
    }else{ 
        //3. layoutmanager未开启自动测量 
    }
} 
``` 
##### 一. 当 __LayoutManager__ 未设置时，不设置View最小值或者padding，不显示 
```java 
if (mLayout == null) { 
    defaultOnMeasure(widthSpec, heightSpec); 
    return; 
} 
//分别测量width 和 height 下面只分析width 
//ViewCompat.getMinimumWidth(this) 返回视图最小宽度 mMinWidth 
void defaultOnMeasure(int widthSpec, int heightSpec) { 
    final int width = LayoutManager.chooseSize(widthSpec,getPaddingLeft() + getPaddingRight(),ViewCompat.getMinimumWidth(this)); 
    final int height = LayoutManager.chooseSize(heightSpec,getPaddingTop() + getPaddingBottom()ViewCompat.getMinimumHeight(this)); 
setMeasuredDimension(width, height); 
} 
public static int chooseSize(int spec, int desired, int min) { 
final int mode = View.MeasureSpec.getMode(spec); 
final int size = View.MeasureSpec.getSize(spec); 
switch (mode) { 
case View.MeasureSpec.EXACTLY: 
//返回match_parent 或者 指定大小 
return size; 
case View.MeasureSpec.AT_MOST: 
//mMinWidth 与 paddingHorizontal取最大值， 再与size取最小值 
return Math.min(size, Math.max(desired, min)); 
case View.MeasureSpec.UNSPECIFIED: 
default: 
//mMinWidth 与 paddingHorizontal取最大值 
return Math.max(desired, min); 
} 
} 
``` 
##### 二. LayoutManager 自动测量 
开启自动测量，在 ``onMeasure()``阶段就把 Children ``layout``完成了。 
```java 
if (mLayout.isAutoMeasureEnabled()) { 
final int widthMode = MeasureSpec.getMode(widthSpec); 
final int heightMode = MeasureSpec.getMode(heightSpec); 
//最后通过recyclerView 调用defaultOnMeasure(int widthSpec, int heightSpec) 
mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); 
//如果width 和 height 都指定了大小，或者 未设置adapter 时，不用再测量子View大小 
final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY && heightMode == MeasureSpec.EXACTLY; 
if (measureSpecModeIsExactly || mAdapter == null) { 
return; 
} 
//mState.mLayoutStep 解释看下面表格 
if (mState.mLayoutStep == State.STEP_START) { 
//看下一个代码块 
dispatchLayoutStep1(); 
} 
// set dimensions in 2nd step. Pre-layout should happen with old dimensions for 
// consistency 
mLayout.setMeasureSpecs(widthSpec, heightSpec); 
mState.mIsMeasuring = true; 
//主要布局测量 
dispatchLayoutStep2(); 
// now we can get the width and height from the children. 
mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); 
// if RecyclerView has non-exact width and height and if there is at least one child 
// which also has non-exact width & height, we have to re-measure. 
if (mLayout.shouldMeasureTwice()) { 
mLayout.setMeasureSpecs( 
MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY), 
MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY)); 
mState.mIsMeasuring = true; 
dispatchLayoutStep2(); 
// now we can get the width and height from the children. 
mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); 
} 
} 
``` 
State | 含义 
- | - 
__State.STEP_START__ | ``mState.mLayoutStep``的默认值，这种情况下，表示 __RecyclerView__ 还未经历 _dispatchLayoutStep1_ ，因为 _dispatchLayoutStep1_ 调用之后 ``mState.mLayoutStep``会变为 __State.STEP_LAYOUT__。 
__State.STEP_LAYOUT__ | 当 ``mState.mLayoutStep``为 __State.STEP_LAYOUT__ 时，表示此时处于``layout``阶段，这个阶段会调用 _dispatchLayoutStep2_ 方法``layout`` __RecyclerView__ 的``children``。调用 _dispatchLayoutStep2_ 方法之后，此时``mState.mLayoutStep``变为了 __State.STEP_ANIMATIONS__。 
__State.STEP_ANIMATIONS__ | 当``mState.mLayoutStep``为 __State.STEP_ANIMATIONS__ 时，表示 __RecyclerView__ 处于第三个阶段，也就是执行动画的阶段，也就是调用 _dispatchLayoutStep3_ 方法。当 _dispatchLayoutStep3_ 方法执行完毕之后，``mState.mLayoutStep``又变为了 __State.STEP_START__ 
###### __1. dispatchLayoutStep1()__ 
本方法也被称为 __preLayout(预布局)__ ，当 __Adapter__ 更新了，这个方法会保存每个 __ItemView__ 的旧信息(oldViewHolderInfo) 
* 处理 __Adapter__ 更新 
* 决定是否执行 __ItemAnimator__ 
* 保存 __ItemView__ 的动画信息。 
```java 
/** 
* - 适配器更新过程 
* - 决定哪些动画应该运行 
* - 保存当前视图的信息 
* - 如果有必要,运行预测布局和保存的信息 
*/ 
private void dispatchLayoutStep1() { 
//检查是State.STEP_START状态 
mState.assertLayoutStep(State.STEP_START); 
fillRemainingScrollValues(mState); 
mState.mIsMeasuring = false; 
startInterceptRequestLayout(); 
mViewInfoStore.clear(); 
onEnterLayoutOrScroll(); 
processAdapterUpdatesAndSetAnimationFlags(); 
saveFocusInfo(); 
mState.mTrackOldChangeHolders = mState.mRunSimpleAnimations && mItemsChanged; 
mItemsAddedOrRemoved = mItemsChanged = false; 
mState.mInPreLayout = mState.mRunPredictiveAnimations; 
mState.mItemCount = mAdapter.getItemCount(); 
findMinMaxChildLayoutPositions(mMinMaxLayoutPositions); 
if (mState.mRunSimpleAnimations) { 
// Step 0: 找到没有被remove的ItemView,保存OldViewHolder信息，准备预布局 
int count = mChildHelper.getChildCount(); 
for (int i = 0; i < count; ++i) { 
final ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); 
if (holder.shouldIgnore() || (holder.isInvalid() && !mAdapter.hasStableIds())) { 
continue; 
} 
final ItemHolderInfo animationInfo = mItemAnimator 
.recordPreLayoutInformation(mState, holder, 
ItemAnimator.buildAdapterChangeFlagsForAnimations(holder), 
holder.getUnmodifiedPayloads()); 
mViewInfoStore.addToPreLayout(holder, animationInfo); 
if (mState.mTrackOldChangeHolders && holder.isUpdated() && !holder.isRemoved() 
&& !holder.shouldIgnore() && !holder.isInvalid()) { 
long key = getChangedHolderKey(holder); 
// This is NOT the only place where a ViewHolder is added to old change holders 
// list. There is another case where: 
// * A VH is currently hidden but not deleted 
// * The hidden item is changed in the adapter 
// * Layout manager decides to layout the item in the pre-Layout pass (step1) 
// When this case is detected, RV will un-hide that view and add to the old 
// change holders list. 
mViewInfoStore.addToOldChangeHolders(key, holder); 
} 
} 
} 
if (mState.mRunPredictiveAnimations) { 
//进行预布局 
// Step 1: run prelayout: This will use the old positions of items. The layout manager 
// is expected to layout everything, even removed items (though not to add removed 
// items back to the container). This gives the pre-layout position of APPEARING views 
// which come into existence as part of the real layout. 
// Save old positions so that LayoutManager can run its mapping logic. 
saveOldPositions(); 
final boolean didStructureChange = mState.mStructureChanged; 
mState.mStructureChanged = false; 
// temporarily disable flag because we are asking for previous layout 
mLayout.onLayoutChildren(mRecycler, mState); 
mState.mStructureChanged = didStructureChange; 
for (int i = 0; i < mChildHelper.getChildCount(); ++i) { 
final View child = mChildHelper.getChildAt(i); 
final ViewHolder viewHolder = getChildViewHolderInt(child); 
if (viewHolder.shouldIgnore()) { 
continue; 
} 
if (!mViewInfoStore.isInPreLayout(viewHolder)) { 
int flags = ItemAnimator.buildAdapterChangeFlagsForAnimations(viewHolder); 
boolean wasHidden = viewHolder 
.hasAnyOfTheFlags(ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); 
if (!wasHidden) { 
flags |= ItemAnimator.FLAG_APPEARED_IN_PRE_LAYOUT; 
} 
final ItemHolderInfo animationInfo = mItemAnimator.recordPreLayoutInformation( 
mState, viewHolder, flags, viewHolder.getUnmodifiedPayloads()); 
if (wasHidden) { 
recordAnimationInfoIfBouncedHiddenView(viewHolder, animationInfo); 
} else { 
mViewInfoStore.addToAppearedInPreLayoutHolders(viewHolder, animationInfo); 
} 
} 
} 
// we don't process disappearing list because they may re-appear in post layout pass. 
clearOldPositions(); 
} else { 
clearOldPositions(); 
} 
onExitLayoutOrScroll(); 
stopInterceptRequestLayout(false); 
//状态改为布局 
mState.mLayoutStep = State.STEP_LAYOUT; 
} 
``` 
_mRunSimpleAnimations_ 与 _mFirstLayoutComplete_ 的值有关， _mRunPredictiveAnimations_ 的值还与 _mRunSimpleAnimations_ 有关。所以这里我们可以得出一个结论,当RecyclerView第一次加载数据时，是不会执行的动画。 换句话说就是 __ItemView__ 还没有 _layout_ 。 
```java 
//在测量和分派的布局使用适配器更新和计算哪种我们想要运行类型的动画 
//这种方法只能处理pre-layout状态更新或全部 
private void processAdapterUpdatesAndSetAnimationFlags() { 
if (mDataSetHasChangedAfterLayout) { 
// Processing these items have no value since data set changed unexpectedly. 
// Instead, we just reset it. 
mAdapterHelper.reset(); 
if (mDispatchItemsChangedEvent) { 
mLayout.onItemsChanged(this); 
} 
} 
// simple animations are a subset of advanced animations (which will cause a 
// pre-layout step) 
// If layout supports predictive animations, pre-process to decide if we want to run them 
if (predictiveItemAnimationsEnabled()) { 
mAdapterHelper.preProcess(); 
} else { 
mAdapterHelper.consumeUpdatesInOnePass(); 
} 
boolean animationTypeSupported = mItemsAddedOrRemoved || mItemsChanged; 
mState.mRunSimpleAnimations = mFirstLayoutComplete 
&& mItemAnimator != null 
&& (mDataSetHasChangedAfterLayout 
|| animationTypeSupported 
|| mLayout.mRequestedSimpleAnimations) 
&& (!mDataSetHasChangedAfterLayout 
|| mAdapter.hasStableIds()); 
mState.mRunPredictiveAnimations = mState.mRunSimpleAnimations 
&& animationTypeSupported 
&& !mDataSetHasChangedAfterLayout 
&& predictiveItemAnimationsEnabled(); 
} 
``` 
###### __2. dispatchLayoutStep2()__ 
本方法进行的是 子View 的测量和布局,放在最后面讲 
主要是 __LayoutManager__ 调用 ``onLayoutChildren()``方法，去布局姿势图。``onLayoutChildren()``是空方法，需要继承 __LayoutManager__ 的子类自己实现，从而决定不同的 __LayoutManager__ 不同的样式。 
```java 
private void dispatchLayoutStep2() { 
startInterceptRequestLayout(); 
onEnterLayoutOrScroll(); 
mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); 
mAdapterHelper.consumeUpdatesInOnePass(); 
mState.mItemCount = mAdapter.getItemCount(); 
mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; 
// Step 2: Run layout 
mState.mInPreLayout = false; 
mLayout.onLayoutChildren(mRecycler, mState); 
mState.mStructureChanged = false; 
mPendingSavedState = null; 
// onLayoutChildren may have caused client code to disable item animations; re-check 
mState.mRunSimpleAnimations = mState.mRunSimpleAnimations && mItemAnimator != null; 
mState.mLayoutStep = State.STEP_ANIMATIONS; 
onExitLayoutOrScroll(); 
stopInterceptRequestLayout(false); 
} 
``` 
##### 三. 没有开启自动测量 
没有开启自动测量，则在layout阶段才布局Children 
接下来又分为两种情况，开启和未开启``setHasFixedSize()`` 
1. 开启``setHasFixedSize()``将直接调用 __LayoutManager__ 的``onMeasure()``方法进行测量。 
2. 未开启``setHasFixedSize()``，此时如果有数据更新，先处理数据更新的事物，然后调用 __LayoutManager__ 的``onMeasure()``方法进行测量。 
```java 
else{ 
if (mHasFixedSize) { 
mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); 
return; 
} 
// custom onMeasure 
if (mAdapterUpdateDuringMeasure) { 
startInterceptRequestLayout(); 
onEnterLayoutOrScroll(); 
processAdapterUpdatesAndSetAnimationFlags(); 
onExitLayoutOrScroll(); 
if (mState.mRunPredictiveAnimations) { 
mState.mInPreLayout = true; 
} else { 
// consume remaining updates to provide a consistent state with the layout pass. 
mAdapterHelper.consumeUpdatesInOnePass(); 
mState.mInPreLayout = false; 
} 
mAdapterUpdateDuringMeasure = false; 
stopInterceptRequestLayout(false); 
} else if (mState.mRunPredictiveAnimations) { 
// If mAdapterUpdateDuringMeasure is false and mRunPredictiveAnimations is true: 
// this means there is already an onMeasure() call performed to handle the pending 
// adapter change, two onMeasure() calls can happen if RV is a child of LinearLayout 
// with layout_width=MATCH_PARENT. RV cannot call LM.onMeasure() second time 
// because getViewForPosition() will crash when LM uses a child to measure. 
setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight()); 
return; 
} 
if (mAdapter != null) { 
mState.mItemCount = mAdapter.getItemCount(); 
} else { 
mState.mItemCount = 0; 
} 
startInterceptRequestLayout(); 
mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); 
stopInterceptRequestLayout(false); 
mState.mInPreLayout = false; // clear 
} 
``` 
## onLayout 
``onLayout()``里面做了两件事，一个是调用了``dispatchLayout()``方法，另一个是 _mFirstLayoutComplete_ 改为了``true``。 
```java 
@Override 
protected void onLayout(boolean changed, int l, int t, int r, int b) { 
TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG); 
dispatchLayout(); 
TraceCompat.endSection(); 
mFirstLayoutComplete = true; 
} 
``` 
##### dispatchLayout() 
先判断 是否有 __Adapter__ 和 __LayoutManager__ ，没有则 __return__ ; 
接下来会有三种情况 
* 当 __mState.mLayoutStep__ 为 __State.STEP_START__ 时，会先执行``dispatchLayoutStep1()``和``dispatchLayoutStep2()``两个方法。 
* __Adapter__ 更新，或者宽高需要重新测量会执行``dispatchLayoutStep2()``方法。 
* 只是将 __RecyclerView__ 的宽高 赋值给 __LayoutManager__ 。 
最后会执行 ``dispatchLayoutStep3()``方法 
```java 
void dispatchLayout() { 
if (mAdapter == null) { 
Log.e(TAG, "No adapter attached; skipping layout"); 
// leave the state in START 
return; 
} 
if (mLayout == null) { 
Log.e(TAG, "No layout manager attached; skipping layout"); 
// leave the state in START 
return; 
} 
mState.mIsMeasuring = false; 
if (mState.mLayoutStep == State.STEP_START) { 
dispatchLayoutStep1(); 
mLayout.setExactMeasureSpecsFrom(this); 
dispatchLayoutStep2(); 
} else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() 
|| mLayout.getHeight() != getHeight()) { 
// First 2 steps are done in onMeasure but looks like we have to run again due to 
// changed size. 
mLayout.setExactMeasureSpecsFrom(this); 
dispatchLayoutStep2(); 
} else { 
// always make sure we sync them (to ensure mode is exact) 
mLayout.setExactMeasureSpecsFrom(this); 
} 
dispatchLayoutStep3(); 
} 
``` 
###### dispatchLayoutStep3() 
这个方法的作用执行在``dispatchLayoutStep1()``方法里面保存的动画信息。 
```java 
private void dispatchLayoutStep3() { 
mState.assertLayoutStep(State.STEP_ANIMATIONS); 
startInterceptRequestLayout(); 
onEnterLayoutOrScroll(); 
//将 mState.mLayoutStep又变为了State.STEP_START 
mState.mLayoutStep = State.STEP_START; 
if (mState.mRunSimpleAnimations) { 
// Step 3: Find out where things are now, and process change animations. 
// traverse list in reverse because we may call animateChange in the loop which may 
// remove the target view holder. 
for (int i = mChildHelper.getChildCount() - 1; i >= 0; i--) { 
ViewHolder holder = getChildViewHolderInt(mChildHelper.getChildAt(i)); 
if (holder.shouldIgnore()) { 
continue; 
} 
long key = getChangedHolderKey(holder); 
final ItemHolderInfo animationInfo = mItemAnimator 
.recordPostLayoutInformation(mState, holder); 
ViewHolder oldChangeViewHolder = mViewInfoStore.getFromOldChangeHolders(key); 
if (oldChangeViewHolder != null && !oldChangeViewHolder.shouldIgnore()) { 
// run a change animation 
// If an Item is CHANGED but the updated version is disappearing, it creates 
// a conflicting case. 
// Since a view that is marked as disappearing is likely to be going out of 
// bounds, we run a change animation. Both views will be cleaned automatically 
// once their animations finish. 
// On the other hand, if it is the same view holder instance, we run a 
// disappearing animation instead because we are not going to rebind the updated 
// VH unless it is enforced by the layout manager. 
final boolean oldDisappearing = mViewInfoStore.isDisappearing( 
oldChangeViewHolder); 
final boolean newDisappearing = mViewInfoStore.isDisappearing(holder); 
if (oldDisappearing && oldChangeViewHolder == holder) { 
// run disappear animation instead of change 
mViewInfoStore.addToPostLayout(holder, animationInfo); 
} else { 
final ItemHolderInfo preInfo = mViewInfoStore.popFromPreLayout( 
oldChangeViewHolder); 
// we add and remove so that any post info is merged. 
mViewInfoStore.addToPostLayout(holder, animationInfo); 
ItemHolderInfo postInfo = mViewInfoStore.popFromPostLayout(holder); 
if (preInfo == null) { 
handleMissingPreInfoForChangeError(key, holder, oldChangeViewHolder); 
} else { 
animateChange(oldChangeViewHolder, holder, preInfo, postInfo, 
oldDisappearing, newDisappearing); 
} 
} 
} else { 
mViewInfoStore.addToPostLayout(holder, animationInfo); 
} 
} 
// Step 4: Process view info lists and trigger animations 
mViewInfoStore.process(mViewInfoProcessCallback); 
} 
mLayout.removeAndRecycleScrapInt(mRecycler); 
mState.mPreviousLayoutItemCount = mState.mItemCount; 
mDataSetHasChangedAfterLayout = false; 
mDispatchItemsChangedEvent = false; 
mState.mRunSimpleAnimations = false; 
mState.mRunPredictiveAnimations = false; 
mLayout.mRequestedSimpleAnimations = false; 
if (mRecycler.mChangedScrap != null) { 
mRecycler.mChangedScrap.clear(); 
} 
if (mLayout.mPrefetchMaxObservedInInitialPrefetch) { 
// Initial prefetch has expanded cache, so reset until next prefetch. 
// This prevents initial prefetches from expanding the cache permanently. 
mLayout.mPrefetchMaxCountObserved = 0; 
mLayout.mPrefetchMaxObservedInInitialPrefetch = false; 
mRecycler.updateViewCacheSize(); 
} 
mLayout.onLayoutCompleted(mState); 
onExitLayoutOrScroll(); 
stopInterceptRequestLayout(false); 
mViewInfoStore.clear(); 
if (didChildRangeChange(mMinMaxLayoutPositions[0], mMinMaxLayoutPositions[1])) { 
dispatchOnScrolled(0, 0); 
} 
recoverFocusFromState(); 
resetFocusInfo(); 
} 
``` 
## draw 
重写了 ``draw()``和 ``onDraw()``两个方法。 
#### draw() 
``draw()``方法分为三步。 
1. 首先调用 ``super.draw()``,将 __Children__ 的绘制分发给 __ViewGroup__ ,将分割线绘制分发给 __ItemDecoration__ 
2. 如果需要的话，调用 __ItemDecoration__ 的 ``onDrawOver``方法。通过这个方法，我们在每个 __ItemView__ 上面画上很多东西。 
3. 如果 __RecyclerView__ 调用了``setClipToPadding()``,会实现一种特殊的滑动效果--每个 __ItemView__ 可以滑动到``padding``区域。 
```java 
public void draw(Canvas c) { 
// 第一步 
super.draw(c); 
// 第二步 
final int count = mItemDecorations.size(); 
for (int i = 0; i < count; i++) { 
mItemDecorations.get(i).onDrawOver(c, this, mState); 
} 
// 第三步 
// TODO If padding is not 0 and clipChildrenToPadding is false, to draw glows properly, we 
// need find children closest to edges. Not sure if it is worth the effort. 
// ······ 
} 
``` 
第一步会回调``onDraw()``方法，调用了 __ItemDecoration__ 的``onDraw()``方法，也就是说``onDraw()``是在 __Itemview__ 绘制之前，``onDrawOver()``是在 __Itemview__ 绘制之后 
```java 
@Override 
public void onDraw(Canvas c) { 
super.onDraw(c); 
final int count = mItemDecorations.size(); 
for (int i = 0; i < count; i++) { 
mItemDecorations.get(i).onDraw(c, this, mState); 
} 
} 
``` 
## LayoutManager的onLayoutChildren方法 
在``dispatchLayoutStep1()``和``dispatchLayoutStep2()``中都有调用， 
它本身没有实现任何东西，需要看他的子类。以 __LinearLayoutManager__ 为例。 
```java 
@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {
    // layout algorithm:
    // 1) by checking children and other variables, find an anchor coordinate and an anchor
    //  item position.
    // 2) fill towards start, stacking from bottom
    // 3) fill towards end, stacking from top
    // 4) scroll to fulfill requirements like stack from bottom.
    // create layout state
    if (DEBUG) {
        Log.d(TAG, "is pre layout:" + state.isPreLayout());
    }
    if (mPendingSavedState != null || mPendingScrollPosition != NO_POSITION) {
        if (state.getItemCount() == 0) {
            removeAndRecycleAllViews(recycler);
            return;
        }
    }
    if (mPendingSavedState != null && mPendingSavedState.hasValidAnchor()) {
        mPendingScrollPosition = mPendingSavedState.mAnchorPosition;
    }

    ensureLayoutState();
    mLayoutState.mRecycle = false;
    // resolve layout direction
    resolveShouldLayoutReverse();

    final View focused = getFocusedChild();
    if (!mAnchorInfo.mValid || mPendingScrollPosition != NO_POSITION
            || mPendingSavedState != null) {
        mAnchorInfo.reset();
        mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd;
        // calculate anchor position and coordinate
        updateAnchorInfoForLayout(recycler, state, mAnchorInfo);
        mAnchorInfo.mValid = true;
    } else if (focused != null && (mOrientationHelper.getDecoratedStart(focused)
                    >= mOrientationHelper.getEndAfterPadding()
            || mOrientationHelper.getDecoratedEnd(focused)
            <= mOrientationHelper.getStartAfterPadding())) {
        // This case relates to when the anchor child is the focused view and due to layout
        // shrinking the focused view fell outside the viewport, e.g. when soft keyboard shows
        // up after tapping an EditText which shrinks RV causing the focused view (The tapped
        // EditText which is the anchor child) to get kicked out of the screen. Will update the
        // anchor coordinate in order to make sure that the focused view is laid out. Otherwise,
        // the available space in layoutState will be calculated as negative preventing the
        // focused view from being laid out in fill.
        // Note that we won't update the anchor position between layout passes (refer to
        // TestResizingRelayoutWithAutoMeasure), which happens if we were to call
        // updateAnchorInfoForLayout for an anchor that's not the focused view (e.g. a reference
        // child which can change between layout passes).
        mAnchorInfo.assignFromViewAndKeepVisibleRect(focused, getPosition(focused));
    }
    if (DEBUG) {
        Log.d(TAG, "Anchor info:" + mAnchorInfo);
    }

    // LLM may decide to layout items for "extra" pixels to account for scrolling target,
    // caching or predictive animations.
    int extraForStart;
    int extraForEnd;
    final int extra = getExtraLayoutSpace(state);
    // If the previous scroll delta was less than zero, the extra space should be laid out
    // at the start. Otherwise, it should be at the end.
    if (mLayoutState.mLastScrollDelta >= 0) {
        extraForEnd = extra;
        extraForStart = 0;
    } else {
        extraForStart = extra;
        extraForEnd = 0;
    }
    extraForStart += mOrientationHelper.getStartAfterPadding();
    extraForEnd += mOrientationHelper.getEndPadding();
    if (state.isPreLayout() && mPendingScrollPosition != NO_POSITION
            && mPendingScrollPositionOffset != INVALID_OFFSET) {
        // if the child is visible and we are going to move it around, we should layout
        // extra items in the opposite direction to make sure new items animate nicely
        // instead of just fading in
        final View existing = findViewByPosition(mPendingScrollPosition);
        if (existing != null) {
            final int current;
            final int upcomingOffset;
            if (mShouldReverseLayout) {
                current = mOrientationHelper.getEndAfterPadding()
                        - mOrientationHelper.getDecoratedEnd(existing);
                upcomingOffset = current - mPendingScrollPositionOffset;
            } else {
                current = mOrientationHelper.getDecoratedStart(existing)
                        - mOrientationHelper.getStartAfterPadding();
                upcomingOffset = mPendingScrollPositionOffset - current;
            }
            if (upcomingOffset > 0) {
                extraForStart += upcomingOffset;
            } else {
                extraForEnd -= upcomingOffset;
            }
        }
    }
    int startOffset;
    int endOffset;
    final int firstLayoutDirection;
    if (mAnchorInfo.mLayoutFromEnd) {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_TAIL
                : LayoutState.ITEM_DIRECTION_HEAD;
    } else {
        firstLayoutDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD
                : LayoutState.ITEM_DIRECTION_TAIL;
    }

    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
    detachAndScrapAttachedViews(recycler);
    mLayoutState.mInfinite = resolveIsInfinite();
    mLayoutState.mIsPreLayout = state.isPreLayout();
    if (mAnchorInfo.mLayoutFromEnd) {
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = extraForStart;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;
        final int firstElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForEnd += mLayoutState.mAvailable;
        }
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = extraForEnd;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;

        if (mLayoutState.mAvailable > 0) {
            // end could not consume all. add more items towards start
            extraForStart = mLayoutState.mAvailable;
            updateLayoutStateToFillStart(firstElement, startOffset);
            mLayoutState.mExtra = extraForStart;
            fill(recycler, mLayoutState, state, false);
            startOffset = mLayoutState.mOffset;
        }
    } else {
        // fill towards end
        updateLayoutStateToFillEnd(mAnchorInfo);
        mLayoutState.mExtra = extraForEnd;
        fill(recycler, mLayoutState, state, false);
        endOffset = mLayoutState.mOffset;
        final int lastElement = mLayoutState.mCurrentPosition;
        if (mLayoutState.mAvailable > 0) {
            extraForStart += mLayoutState.mAvailable;
        }
        // fill towards start
        updateLayoutStateToFillStart(mAnchorInfo);
        mLayoutState.mExtra = extraForStart;
        mLayoutState.mCurrentPosition += mLayoutState.mItemDirection;
        fill(recycler, mLayoutState, state, false);
        startOffset = mLayoutState.mOffset;

        if (mLayoutState.mAvailable > 0) {
            extraForEnd = mLayoutState.mAvailable;
            // start could not consume all it should. add more items towards end
            updateLayoutStateToFillEnd(lastElement, endOffset);
            mLayoutState.mExtra = extraForEnd;
            fill(recycler, mLayoutState, state, false);
            endOffset = mLayoutState.mOffset;
        }
    }

    // changes may cause gaps on the UI, try to fix them.
    // TODO we can probably avoid this if neither stackFromEnd/reverseLayout/RTL values have
    // changed
    if (getChildCount() > 0) {
        // because layout from end may be changed by scroll to position
        // we re-calculate it.
        // find which side we should check for gaps.
        if (mShouldReverseLayout ^ mStackFromEnd) {
            int fixOffset = fixLayoutEndGap(endOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutStartGap(startOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        } else {
            int fixOffset = fixLayoutStartGap(startOffset, recycler, state, true);
            startOffset += fixOffset;
            endOffset += fixOffset;
            fixOffset = fixLayoutEndGap(endOffset, recycler, state, false);
            startOffset += fixOffset;
            endOffset += fixOffset;
        }
    }
    layoutForPredictiveAnimations(recycler, state, startOffset, endOffset);
    if (!state.isPreLayout()) {
        mOrientationHelper.onLayoutComplete();
    } else {
        mAnchorInfo.reset();
    }
    mLastStackFromEnd = mStackFromEnd;
    if (DEBUG) {
        validateChildOrder();
    }
}
``` 




